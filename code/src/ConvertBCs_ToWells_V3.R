## Greg Booth 02/14/2020
## For 2 level sciATAC only
## This script has two functions that are called so that you can convert a string of barcode strings (generated by hannah's barcode helper script) 
## into the PCR and RT well IDs
## this is useful because the hash analysis pipeline reports Hashes by the PCR and RT wells that they originated from. 
## Therefore, after using this script you can more readily pair hash IDs with their corresponding ATAC data. 
## These functions were based on data frame of reads intersected with MACS Peak as output from hannah's sciATAC pipeline  

library(dplyr)
P7_bcs <- c("TCGGATTCGG","GCGGCTGCGG","AGATTACGTT","CTAACTAGGT","CATAGCGACC","CCGCTAAGAG","ATGGAACGAA","GCGTTCCGTT","GGTTATCGAA","GCATCGTATG","AATACGATAA","TTCCGTCGAC", 
            "TCCGGCTTAT","ACCAGGCGCA","AGAGGAGAAT","GTACTCCTAT","GCTAACGGAT","AGTTGAATCA","TGATTAGGTA","TCGTAGCATC","TCTTGAGGTT","AGGTCAGCTT","TATTAGACTT","CTCAATTAGT", 
            "TCGCCGCCGG","CCGTATGATT","AACGCGCAGA","CTCGTCGTAG","CTAATTGCGA","CGCGGCCATA","AATATTACTT","ATTGGCAGAT","ATGGCGCCTG","ATAAGGACTC","TAGTAAGCCG","ATTATGCAAG",
            "TTGGCAAGCC","TTGATTGGCG","GCATATGAGC","GAACTCGACT","CTAGCCAGCC","TGCGACCTCT","ATTCTTAGCT","TTGATACGAT","TATAATAGTT","TTGCCGTAGG","AGACCATATC","TTGGTAAGGA",
            "CAGCTAGCGG","CTAAGCCTTG","CGTTACCGCT","GACTGGACCA","GCAAGACCGT","TCAATCTCCT","ATACCTCGAC","TAGAGGCGTT","TAGGTAACTT","TTCGAATATT","TGGACGACTA","GTAGGCTGCA",
            "GTAGGATAAG","CGTCGAGCGC","ACTATTCATT","TTGCTTAGAT","CGAATGGAGC","CTATATAGCC","CTACTAATAA","TGGTTGCCGT","TCCTCTGCCG","GATTCTTGAA","GTAGCAGCTA","CCTCAGCTCC",
            "AAGTAGCTCA","TATTGCTGGA","CCAGATACGG","AACGAATTCG","CGCTTATCGT","AAGTACGCGA","GATCTTCGCA","TCTTAGCCTG","TTATTGAGGC","TTGCGAGCAT","GCTTGAAGAG","AGTCCGCTGC",
            "TAAGTCCTGA","AGTTCTCATG","CAGACTAAGG","TCTATCGCTG","GCGCTATGGT","CATTATTATT","AGCCGTAGTT","TGATATTGCG","ACGGCGTTAA","GGCTTACTCC","GCGCGTTCAT","GAGCGCGATG")


P5_bcs  <- c("CTCCATCGAG","TTGGTAGTCG","GGCCGTCAAC","CCTAGACGAG","TCGTTAGAGC","CGTTCTATCA","CGGAATCTAA","ATGACTGATC",
             "TCAATATCGA","GTAGACCTGG","TTATGACCAA","TTGGTCCGTT","GGTACGTTAA","CAATGAGTCC","GATGCAGTTC","CCATCGTTCC",
             "TTGAGAGAGT","ACTGAGCGAC","TGAGGAATCA","CCTCCGACGG","CATTGACGCT","TCGTCCTTCG","TGATACTCAA","TTCTACCTCA",
             "TCGTCGGAAC","ATCGAGATGA","TAGACTAGTC","GTCGAAGCAG","AGGCGCTAGG","AGATGCAACT","AAGCCTACGA","GTAGGCAATT",
             "GGAGGCGGCG","CCAGTACTTG","GGTCTCGCCG","GGCGGAGGTC","TAGTTCTAGA","TTGGAGTTAG","AGATCTTGGT","GTAATGATCG",
             "CAGAGAGGTC","TTAATTAGCC","CTCTAACTCG","TACGATCATC","AGGCGAGAGC","TCAAGATAGT","TAATTGACCT","CAGCCGGCTT",
             "AGAACCGGAG","GAGATGCATG","GATTACCGGA","TCGTAACGGT","TGGCGACGGA","AGTCATAGCC","GTCAAGTCCA","ATTCGGAAGT",
             "GTCGGTAGTT","AGGACGGACG","CTCCTGGACC","TAGCCTCGTT","GGTTGAACGT","AGGTCCTCGT","GGAAGTTATA","TGGTAATCCT",
             "AAGCTAGGTT","TCCGCGGACT","TGCGGATAGT","TGGCAGCTCG","TGCTACGGTC","GCGCAATGAC","CTTAATCTTG","GGAGTTGCGT",
             "ACTCGTATCA","GGTAATAATG","TCCTTATAGA","CCGACTCCAA","GCCAAGCTTG","CATATCCTAT","ACCTACGCCA","GGAATTCAGT",
             "TGGCGTAGAA","ATTGCGGCCA","TTCAGCTTGG","CCATCTGGCA","CTTATAAGTT","GATTAGATGA","TATAGGATCT","AGCTTATAGG",
             "GTCTGCAATC","CGCCTCTTAT","GTTGGATCTT","GCGATTGCAG","TGCCAGTTGC","CTTAGGTATC","GAGACCTACC","ATTGACCGAG")

n1 <- c("ATTACTCG","TCCGGAGA","CGCTCATT","GAGATTCC","ATTCAGAA","GAATTCGT","CTGAAGCT","TAATGCGC","CGGCTATG","TCCGCGAA","TCTCGCGC","AGCGATAG")
n2 <- c("TATAGCCT","ATAGAGGC","CCTATCCT","GGCTCTGA","AGGCGAAG","TAATCTTA","CAGGACGT","GTACTGAC")

# create df with Tn5 bcs matched to wells
create_RT_IDs = function(n5 = n1, n7 = n2){
  TN5seqs = expand.grid(n7, n5) # order critical so that it goes column-wise
  TN5_combos = cbind(paste0(TN5seqs$Var2, TN5seqs$Var1), 0:95)
  TN5_combos = data.frame(TN5_combos, stringsAsFactors = FALSE)
  colnames(TN5_combos) <-c("Tn5seq", "RTwell")
  return(TN5_combos)
}

RT_map = create_RT_IDs(n5 = n1, n7 = n2)

BCtoWellIDs = function(seq, P7List = P7_bcs, P5List = P5_bcs){
  P7bc = stringr::str_sub(seq, 9,18)
  P5bc = stringr::str_sub(seq, 19,28)
  P7pos = match(P7bc, P7_bcs)
  P5pos = match(P5bc, P5_bcs)
  P7row = ifelse(P7pos%%12 == 0, P7pos/12, floor(P7pos / 12) + 1)
  P7col = ifelse(P7pos%%12 == 0, 12, P7pos %% 12)
  P5row = ifelse(P5pos %% 8 == 0, 8, P5pos %% 8)
  P5col = ifelse(P5pos %% 8 == 0, P5pos/8, floor(P5pos / 8) + 1)
  row_col = paste0(LETTERS[P5row], ifelse(P7col >= 10, P7col, paste0("0", P7col)), "_", LETTERS[P7row], ifelse(P5col >= 10, P5col, paste0("0", P5col)))
  tn5idx = paste0(substring(seq, 1, 8), substring(seq, 29, 36))
  RTwell = filter(RT_map, Tn5seq == tn5idx)
  row_col_RTwell = paste0(row_col, "_RT_", as.character(RTwell$RTwell))
  return(row_col_RTwell)
}

### for testing 
#tseq = "TAATGCGCGCATCGTATGATTCGGAAGTTATAGCCT" #asmnt should return H10_A07_RT_56
#BCtoWellIDs(sequence = tseq)


